#!/usr/bin/env bash

set -euo pipefail

# capture script exit
cleanup()
{
	local rc=$?
	info "exited with error level ${rc}"
	exit ${rc}
}

# get the command name without path
cmd()	{ basename "${0}" ; }

# determine absolute path to a provided file/folder
abs()	{ echo "$(cd "$(dirname "${1}")" && pwd)/$(basename "${1}")"; }

# append timestamp and loglevel prints
debug()		{ if [ "${debug_enabled:-}" == "true" ]; then 
			  echo "$(date)  [DEBUG]   $*" ; fi ; }
info()		{ echo "$(date)  [INFO]    $*" ; }
warning()	{ echo "$(date)  [WARNING] $*" ; }
error()		{ echo "$(date)  [ERROR]   $*" ; }
fatal()		{ echo "$(date)  [FATAL]   $*" ; exit 1 ; }

usage()
{
    cat <<EOF

Usage:
                $(cmd) [service]
Description:
                update an existing service with latest image from docker hub;
                even if no changes are required;
Examples:
                $(cmd) plex
                $(cmd) nzbget --debug
                $(cmd) --help
Parameters:
                --help      display this help message

                --debug     enable debug logs

EOF
exit 2
}

# exit here if this script was sourced
[[ "${BASH_SOURCE[0]:-${0}}" != "${0}" ]] && return

# trap any exit code beyond this point
trap cleanup INT TERM EXIT

# set defaults
debug_enabled="false"

# catch help param
expr "$*" : ".*--help" > /dev/null && usage

# catch debug param
expr "$*" : ".*--debug" > /dev/null && debug_enabled="true"

readonly bin_dir="$(dirname "$(abs "${0}")")"
debug "bin_dir: ${bin_dir}"

[ -n "${1:-}" ] || fatal "service name is required"

readonly service_name="mediaserver_${1/mediaserver_/}"

docker service ls | grep -q "${service_name}" || fatal "service ${service_name} does not exist"

info "updating service ${service_name} ..."
docker service update --detach=true --force ${service_name}
info "... task is running in background"
info "check status with 'watch docker service ls' or 'watch docker ps'"
