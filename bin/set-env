#!/usr/bin/env bash

set -euo pipefail

# capture script exit
cleanup()
{
	local rc=$?
	info "exited with error level ${rc}"
	rm "${bin_dir:?}"/../*/*.env.new* &>/dev/null || true
	exit ${rc}
}

# get the command name without path
cmd()   { basename "${0}" ; }

# determine absolute path to a provided file/folder
abs()   { echo "$(cd "$(dirname "${1}")" && pwd)/$(basename "${1}")"; }

# append timestamp and loglevel prints
debug()     { if [ "${debug_enabled:-}" == "true" ]; then 
			  echo "$(date)  [DEBUG]   $*" ; fi ; }
info()      { echo "$(date)  [INFO]    $*" ; }
warning()   { echo "$(date)  [WARNING] $*" ; }
error()     { echo "$(date)  [ERROR]   $*" ; }
fatal()     { echo "$(date)  [FATAL]   $*" ; exit 1 ; }

usage()
{
	cat <<EOF

Usage:
				$(cmd)
Description:
				set environment variables used by docker containers;
				each associated .env file will be updated with the values provided;
				this script is for convenience, the files can be updated manually
Examples:
				$(cmd)
				$(cmd) --debug
				$(cmd) --help
Parameters:
				--help      display this help message

				--debug     enable debug logs

EOF
exit 2
}

# exit here if this script was sourced
[[ "${BASH_SOURCE[0]:-${0}}" != "${0}" ]] && return

# trap any exit code beyond this point
trap cleanup INT TERM EXIT

# set defaults
debug_enabled="false"

# catch help param
expr "$*" : ".*--help" > /dev/null && usage

# catch debug param
expr "$*" : ".*--debug" > /dev/null && debug_enabled="true"

readonly bin_dir="$(dirname "$(abs "${0}")")"
debug "bin_dir: ${bin_dir}"

cached_email=""
cached_host=""

process_env_file()
{
	local curr_env_file
	local curr_param_name
	local curr_param_val

	local new_env_file
	local new_param_val

	local suggested_param_val

	curr_env_file="${1}"
	new_env_file="$(dirname "${env_file}")/$(basename "${env_file}").new"

	[ -e "${new_env_file}" ] && rm -rf "${new_env_file}"

	while read -r line
	do
		# echo comments for context
		if [[ "${line}" == "# "* ]]
		then
			echo "${line}"
		fi


		if [[ "${line}" != *"="* ]]
		then
			echo "${line}" >> "${new_env_file}"
			continue
		fi

		curr_param_name="$(echo "${line}" | awk -F"=" '{print $1}')"
		curr_param_val="$(echo "${line}" | awk -F"=" '{print $2}')"
		new_param_val=""

		# default to existing value
		suggested_param_val="${curr_param_val}"

		if [[ "${curr_param_name}" == "#"* ]]
		then
			# default to disabled
			curr_param_name="${curr_param_name/\#/}"
			suggested_param_val="#"
		fi

		if [ -n "${cached_email}" ]
		then
			# replace example email with cached email
			suggested_param_val="${suggested_param_val//example@email.com/${cached_email}}"
		fi

		if [ -n "${cached_host}" ]
		then
			# replace example host with cached host
			suggested_param_val="${suggested_param_val//exampledomain.com/${cached_host}}"
		fi
	
		# prompt for new value
		read -r -e -p "${curr_param_name} (unset with #): " -i "${suggested_param_val}" new_param_val < /dev/tty
		echo

		if [ "${new_param_val}" == "#" ]
		then
			# disabled
			echo "#${curr_param_name}=${curr_param_val}" >> "${new_env_file}"
			continue
		fi

		# enabled
		echo "${curr_param_name}=${new_param_val}" >> "${new_env_file}"

		case "${curr_param_name}" in
			# cache email for later
			*"_EMAIL")	cached_email="${new_param_val}" ;;
			# cache the first host for later
			*"_HOST")	cached_host="${new_param_val%%,*}" && cached_host="${cached_host#*.}" ;;
		esac

	done < "${curr_env_file}"

	mv "${new_env_file}" "${curr_env_file}"

	info "updated '$(basename "${curr_env_file}")'"
}

# iterate over .env.example files
for example_file in ${bin_dir}/../*/*.env.example
do
	# copy sample file if env file does not exist
	env_file="${example_file%.*}"
	[ -f "${env_file}" ] || cp "${example_file}" "${env_file}"
done

# iterate over .env files
for env_file in ${bin_dir}/../*/*.env
do
	info "processing '$(basename "${env_file}")'..."
	echo
	process_env_file "$(abs "${env_file}")"
done

